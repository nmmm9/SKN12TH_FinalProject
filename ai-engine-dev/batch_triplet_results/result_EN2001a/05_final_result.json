[
  {
    "timestamp": "00:28",
    "timestamp_order": "14-1",
    "speaker": "Speaker_A",
    "text": "[TGT] 음, 그 사람은 다음 주인 6주차에 프로토타입을 만들어 보는 게 어떨지 생각해 봐야 한다고 하더군요. [/TGT]"
  },
  {
    "timestamp": "01:32",
    "timestamp_order": "26-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 네, 오늘 회의는 데이터 구조를 정하는 자리라고 생각해요. [/TGT]"
  },
  {
    "timestamp": "01:54",
    "timestamp_order": "30-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 우선 NITE XML을 다시 살펴보고 우리가 원하는 것이 NITE XML에서 제공하는 기능과 얼마나 호환되는지 확인해 보세요. [/TGT]"
  },
  {
    "timestamp": "02:08",
    "timestamp_order": "33-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그래서 오늘, 그리고 나중에, 어쩌면 오늘이라도 어떤 데이터를 갖고 싶은지 결정한다면, NITE XML을 살펴보거나, 아니면 저희 중 일부는 NITE XML을 좀 더 자세히 살펴보고, 그 코드를 이해하고 시스템에서 어떻게 표현되는지 살펴보는 것이 좋을 것 같습니다. [/TGT]"
  },
  {
    "timestamp": "02:08",
    "timestamp_order": "34-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그리고 그런 지식을 바탕으로 좋아, 이런 유형의 NITE XML 데이터를 로드하고 싶고, 이렇게 하면 모두가 접근할 수 있겠다라고 말할 수 있어야 합니다. [/TGT]"
  },
  {
    "timestamp": "02:41",
    "timestamp_order": "41-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 설명서를 살펴봤는데, NITE XML 프레임워크를 사용하는 게 좋겠다는 생각이 들 정도로 충분히 봤습니다. [/TGT]"
  },
  {
    "timestamp": "02:41",
    "timestamp_order": "42-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 왜냐하면 그들은 데이터와 모든 디스플레이 요소를 동기화하는 좋은 이벤트 모델을 가지고 있기 때문입니다. [/TGT]"
  },
  {
    "timestamp": "02:41",
    "timestamp_order": "44-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그들의 프레임워크를 고수하고 그들의 일반 클래스를 사용하는 이유가 될 수 있습니다. [/TGT]"
  },
  {
    "timestamp": "03:31",
    "timestamp_order": "51-1",
    "speaker": "Speaker_C",
    "text": "[TGT] 기본 단어 중요도도 오프라인과 동일합니다. [/TGT]"
  },
  {
    "timestamp": "03:31",
    "timestamp_order": "52-1",
    "speaker": "Speaker_C",
    "text": "[TGT] 사용자가 검색창에 입력한 내용을 기다리려면 통합 측정값이 적절하지 않을 수 있습니다. [/TGT]"
  },
  {
    "timestamp": "03:51",
    "timestamp_order": "60-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 따라서 기본적으로 디스플레이 모듈과 디스플레이 자체를 제외하면, 물건을 만드는 모듈과 인터페이스 사이에 상호작용이 거의 없습니다. [/TGT]"
  },
  {
    "timestamp": "03:51",
    "timestamp_order": "61-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 따라서 인터페이스는 주로 파일에서 로드한 데이터를 작업하는 동안만 실행됩니다. [/TGT]"
  },
  {
    "timestamp": "04:17",
    "timestamp_order": "70-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 즉, 적어도 누군가가 온라인 데이터에 대해 수십억 번의 계산을 해야 하는 상황은 겪지 않는다는 뜻이에요. [/TGT]"
  },
  {
    "timestamp": "04:17",
    "timestamp_order": "71-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그렇게 되면 데이터에 대한 인터페이스가 성능과 모든 면에서 훨씬 더 신중해야 한다는 뜻이죠. [/TGT]"
  },
  {
    "timestamp": "04:55",
    "timestamp_order": "77-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 기본적으로 브라우저는 사실상 뷰어 역할을 하는 셈인데, 데이터의 일부를 선택해서 표시하는 것 외에는 별다른 작업을 하지 않습니다. [/TGT]"
  },
  {
    "timestamp": "05:26",
    "timestamp_order": "87-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 어차피 그 부분을 데이터베이스에 넣을 거라면, 원하는 모든 필드를 데이터베이스에 넣고 거기서 모든 걸 계산하는 게 낫겠죠. [/TGT]"
  },
  {
    "timestamp": "05:26",
    "timestamp_order": "88-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그러면 기본 XML 표현 방식에 대해 크게 신경 쓸 필요도 없고, 그냥 쿼리만 치면 되니까요. [/TGT]"
  },
  {
    "timestamp": "05:48",
    "timestamp_order": "91-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그리고 디스플레이 자체와 마찬가지로, XML에 있는 것이 SQL에 있는 것보다 더 쉽다고 생각합니다. [/TGT]"
  },
  {
    "timestamp": "05:48",
    "timestamp_order": "92-1",
    "speaker": "Speaker_E",
    "text": "[TGT] XML에 있는 경우, 모든 레벨에서 동기화를 위한 모든 기능을 갖춘 NITE XML 프레임워크가 있어서 변경 사항이 있거나 무언가가 진행될 때마다 동기화할 수 있기 때문입니다. [/TGT]"
  },
  {
    "timestamp": "05:48",
    "timestamp_order": "94-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그래서 실제 브라우저 자체에서 XML에 있을 수 있다면 SQL에 있고 싶지 않습니다. [/TGT]"
  },
  {
    "timestamp": "05:48",
    "timestamp_order": "95-1",
    "speaker": "Speaker_E",
    "text": "[TGT] XML에 있으면 많은 도움을 받을 수 있기 때문입니다. [/TGT]"
  },
  {
    "timestamp": "06:33",
    "timestamp_order": "97-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 글쎄요, 그렇게 하려면 모든 것을 XML 형식으로 저장해야 할 겁니다. [/TGT]"
  },
  {
    "timestamp": "07:23",
    "timestamp_order": "106-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그래야 인터페이스가 전체 회의 시리즈의 회의인지, 아니면 회의 내의 특정 부분인지 신경 쓸 필요가 없으니까요. [/TGT]"
  },
  {
    "timestamp": "07:23",
    "timestamp_order": "112-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 전체 코퍼스가 아니라 한 가지 주제와 관련된 모든 회의를 말하는 거죠. [/TGT]"
  },
  {
    "timestamp": "08:14",
    "timestamp_order": "119-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 오프라인에서 정보 밀도를 계산했다면, 전체 내용을 하나의 거대한 문서로 처리하기만 하면 되니까요. [/TGT]"
  },
  {
    "timestamp": "08:31",
    "timestamp_order": "123-1",
    "speaker": "Speaker_B",
    "text": "[TGT] 그리고 확대/축소 수준에 따라 일부만 표시하는 거죠. [/TGT]"
  },
  {
    "timestamp": "09:02",
    "timestamp_order": "127-1",
    "speaker": "Speaker_B",
    "text": "[TGT] 예를 들어 회의 시리즈 요약에 표시하려는 시퀀스에 높은 값을 부여할 수 있습니다. [/TGT]"
  },
  {
    "timestamp": "09:11",
    "timestamp_order": "131-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그러니까, 네, 그러니까 단일 회의에서 전체 회의 시리즈를 더블 클릭하면 기본적으로 발생하는 유일한 일은 확대/축소 수준이 변경된다는 겁니다. [/TGT]"
  },
  {
    "timestamp": "09:11",
    "timestamp_order": "132-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 시작과 끝 위치가 바뀌고 확대/축소 수준도 바뀌죠. [/TGT]"
  },
  {
    "timestamp": "09:38",
    "timestamp_order": "139-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 결국 정보 밀도 측정에 의존하게 될 텐데, 그렇게 하는 건 별 의미가 없다고 생각합니다. [/TGT]"
  },
  {
    "timestamp": "09:38",
    "timestamp_order": "141-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그러니까 실제로 하는 건 목록을 정렬하는 거고, 그게 계산적으로 어려운 부분인가요? [/TGT]"
  },
  {
    "timestamp": "09:58",
    "timestamp_order": "142-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 음, 우리가 계산하는 아이디어는 전체 코퍼스의 모든 발화에 대해 오프라인에서 먼저 정보 밀도를 계산하는 거죠? [/TGT]"
  },
  {
    "timestamp": "09:58",
    "timestamp_order": "143-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그러니까 일련의 회의를 볼 때, 전체 문서가 이 모든 것들을 하나로 묶어 구성되었다고 가정하는 거죠. [/TGT]"
  },
  {
    "timestamp": "09:58",
    "timestamp_order": "144-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그리고 정보 밀도별로 정렬하기만 하면 됩니다. [/TGT]"
  },
  {
    "timestamp": "11:02",
    "timestamp_order": "166-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 선택지조차 개별 단어의 우선순위나 개별 발화의 우선순위에 따라 자동으로 요약이 제공될까요? [/TGT]"
  },
  {
    "timestamp": "11:25",
    "timestamp_order": "170-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그러니까 정보 밀도가 가장 높은 발화는 평균적인 정보 밀도를 갖는 거죠. [/TGT]"
  },
  {
    "timestamp": "11:32",
    "timestamp_order": "172-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 발화 수준에서 전체를 분석하는 건가요? [/TGT]"
  },
  {
    "timestamp": "11:32",
    "timestamp_order": "173-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 아니면 정보 밀도 계산처럼 단어 수준에서 분석하는 건가요? [/TGT]"
  },
  {
    "timestamp": "11:35",
    "timestamp_order": "174-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 단어 단위로 작업하는 데 문제는 오디오를 동기화하려고 하면 해당 단어만 추출할 방법이 없다는 겁니다. [/TGT]"
  },
  {
    "timestamp": "12:57",
    "timestamp_order": "204-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 내부적으로 계산해야 한다면 그렇게 할 수 있죠. [/TGT]"
  },
  {
    "timestamp": "12:57",
    "timestamp_order": "205-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 하지만 개별 단어의 중요도 수준을 저장하지 않고 발화 전체에 순위를 매기는 건 어떨까요? [/TGT]"
  },
  {
    "timestamp": "13:19",
    "timestamp_order": "212-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 스키밍이 더 나을 수도 있고, 동시에 메모리 사용량도 줄일 수 있으니까요. [/TGT]"
  },
  {
    "timestamp": "13:44",
    "timestamp_order": "218-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그래서 우리는 그것을 발화 수준에서만 저장하는 것에 대해 생각하고 있습니다. [/TGT]"
  },
  {
    "timestamp": "13:52",
    "timestamp_order": "220-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그리고 디스플레이에서는 발화 전체를 보여주는 게, 발화에서 단어 하나만 빼는 것보다 나을 겁니다. [/TGT]"
  },
  {
    "timestamp": "13:52",
    "timestamp_order": "223-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그러니까 알고리즘에 실제로 큰 차이는 없을 겁니다. [/TGT]"
  },
  {
    "timestamp": "14:15",
    "timestamp_order": "228-1",
    "speaker": "Speaker_B",
    "text": "[TGT] 네, 그리고 그 측정값을 제가 핫스팟 등에서 얻은 측정값과 결합하는 것도 생각해 봤어요. [/TGT]"
  },
  {
    "timestamp": "14:15",
    "timestamp_order": "229-1",
    "speaker": "Speaker_B",
    "text": "[TGT] 그러면 발화 수준에서도 측정할 수 있을 것 같아요. [/TGT]"
  },
  {
    "timestamp": "15:17",
    "timestamp_order": "247-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그러면 특정 임계값을 넘을 때만 단어의 가치가 결정되는 거죠. [/TGT]"
  },
  {
    "timestamp": "15:31",
    "timestamp_order": "251-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 음, 저희는 전체적으로 일종의 사전 필터링을 합니다. [/TGT]"
  },
  {
    "timestamp": "15:48",
    "timestamp_order": "258-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그 구체적인 질문에 답하기 전에, 어떻게 처리해야 할지 먼저 오디오 플레이어가 무엇을 할 수 있는지 살펴보는 게 좋을 것 같아요. [/TGT]"
  },
  {
    "timestamp": "15:58",
    "timestamp_order": "259-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 오디오 버퍼링을 해야 할 것 같아요. [/TGT]"
  },
  {
    "timestamp": "16:11",
    "timestamp_order": "266-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 하지만 하드 디스크에 저장한 다음 로드하는 것이 아니라 메모리에서 직접 로드하는 거죠. [/TGT]"
  },
  {
    "timestamp": "16:35",
    "timestamp_order": "274-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 좋아요, 그러니까 제 말은, 발화 단위로 접근하더라도 발화 내에서 전혀 관련 없는 부분을 삭제하는 데에는 여전히 장점이 있다는 뜻이에요. [/TGT]"
  },
  {
    "timestamp": "16:56",
    "timestamp_order": "279-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 음, 제가 시도해 볼 만한 것은 기본적으로 서로 다른 파형의 연결 리스트를 공급하는 클래스를 만드는 것입니다. [/TGT]"
  },
  {
    "timestamp": "17:12",
    "timestamp_order": "281-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 네, 어쩌면 제가 말하고자 하는 것은 그것이 얼마나 발전했느냐에 달려 있다는 것입니다. [/TGT]"
  },
  {
    "timestamp": "17:12",
    "timestamp_order": "285-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그래서 플레이어가 메모리에서 어떤 입력을 받아들이고, 그것이 쉽게 수행될 수 있다면, 그것은 상당히 가능하다고 생각합니다. [/TGT]"
  },
  {
    "timestamp": "17:12",
    "timestamp_order": "287-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그래서 우리는 회의 시리즈 전체에 대한 메모리에 발언과 발언의 순위, 그리고 발언과 관련된 정보, 누가 말하고 있는지를 알려주는 정보를 로드합니다. [/TGT]"
  },
  {
    "timestamp": "18:20",
    "timestamp_order": "297-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 반면에, RAM 용량이 50메가바이트 정도면 안 된다는 말씀이시죠. [/TGT]"
  },
  {
    "timestamp": "18:40",
    "timestamp_order": "302-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 프로젝트에 모든 것을 로드하고, 로드하는 모든 데이터를 프로젝트에 로드하면 오류 메시지가 표시됩니다. [/TGT]"
  },
  {
    "timestamp": "18:40",
    "timestamp_order": "304-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그래서 우리의 희망은 로드하는 양을 줄이는 것입니다. [/TGT]"
  },
  {
    "timestamp": "18:54",
    "timestamp_order": "309-1",
    "speaker": "Speaker_A",
    "text": "[TGT] 요청에 따라 로드된다는 뜻입니다. [/TGT]"
  },
  {
    "timestamp": "19:20",
    "timestamp_order": "313-1",
    "speaker": "Speaker_A",
    "text": "[TGT] 필요한 특정 항목만 로드하는 거죠. [/TGT]"
  },
  {
    "timestamp": "19:27",
    "timestamp_order": "314-1",
    "speaker": "Speaker_A",
    "text": "[TGT] 하지만 전체 코퍼스에 대한 검색을 수행하려면 모든 항목을 로드해야 합니다. [/TGT]"
  },
  {
    "timestamp": "19:29",
    "timestamp_order": "315-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 네, 하지만 네, 하지만 음, 음, NITE XML 키트를 로드하자마자 실패했어요. [/TGT]"
  },
  {
    "timestamp": "19:40",
    "timestamp_order": "322-1",
    "speaker": "Speaker_B",
    "text": "[TGT] 요청 시에만 로드합니다. [/TGT]"
  },
  {
    "timestamp": "20:27",
    "timestamp_order": "330-1",
    "speaker": "Speaker_E",
    "text": "[TGT] av에서 전체 시리즈를 표현하는 것과 매우 유사한 구조로, 개별 회의를 표현하는 구조와 유사하지만, 항상 전체 시리즈의 데이터를 결합합니다. [/TGT]"
  },
  {
    "timestamp": "20:54",
    "timestamp_order": "334-1",
    "speaker": "Speaker_B",
    "text": "[TGT] 예를 들어 최상위 요약과 각 레벨별로 별도의 파일을 만드는 거죠. [/TGT]"
  },
  {
    "timestamp": "21:18",
    "timestamp_order": "337-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 메모리에 새 XML 문서를 생성하기만 하면 됩니다. [/TGT]"
  },
  {
    "timestamp": "22:16",
    "timestamp_order": "344-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 할 수 있는 건 한 번에 조금씩 처리하는 것뿐입니다. [/TGT]"
  },
  {
    "timestamp": "22:16",
    "timestamp_order": "347-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 지금까지 요약에 있는 발화보다 점수가 높으면 그냥 바꾸면 됩니다. [/TGT]"
  },
  {
    "timestamp": "22:16",
    "timestamp_order": "348-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그러면 한 번에 하나의 회의만 처리하면 됩니다. [/TGT]"
  },
  {
    "timestamp": "22:43",
    "timestamp_order": "350-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 예를 들어 디스플레이 같은 경우, 전체 시리즈를 보여주는 디스플레이가 필요하다면, 정보 밀도 수준은 f와 f에 기반하고, 유일한 세부 사항은 개별 발화뿐이므로, 70시간에 걸친 일련의 회의에서 모든 발화를 하나하나 살펴봐야 한다는 뜻입니다. [/TGT]"
  },
  {
    "timestamp": "23:03",
    "timestamp_order": "351-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 좋아요, 그러면 세그먼트와 회의에 대한 평균 측정 기준도 만들어야 할까요? [/TGT]"
  },
  {
    "timestamp": "23:42",
    "timestamp_order": "362-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 스피커와 주제 세분화도 필요할 거예요. [/TGT]"
  },
  {
    "timestamp": "24:23",
    "timestamp_order": "366-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 하지만 스키밍과 검색에 필요한 데이터는 충분하죠. [/TGT]"
  },
  {
    "timestamp": "24:23",
    "timestamp_order": "368-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그런 다음 NITE XML에서 해당 시간 마크로 위치를 설정할 수 있는 방법이 있을 거라고 확신합니다. [/TGT]"
  },
  {
    "timestamp": "24:23",
    "timestamp_order": "369-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그러면 전체 프레임이 이동하고 디스플레이의 모든 요소에 알림을 보내 디스플레이가 업데이트됩니다. [/TGT]"
  },
  {
    "timestamp": "24:51",
    "timestamp_order": "372-1",
    "speaker": "Speaker_A",
    "text": "[TGT] 네, 여러 결과에 대해 작은 트리 디스플레이를 개발하고 싶지는 않습니다. [/TGT]"
  },
  {
    "timestamp": "25:40",
    "timestamp_order": "377-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 모든 창 처리에 적용되는 이벤트는 기본적으로 동일합니다. [/TGT]"
  },
  {
    "timestamp": "25:57",
    "timestamp_order": "380-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 따라서 우리는 기본적으로 메모리에 우리만의 XML 문서를 만들어야 합니다. [/TGT]"
  },
  {
    "timestamp": "26:07",
    "timestamp_order": "382-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 모듈은 기본 데이터가 아니라 해당 항목을 변경합니다. [/TGT]"
  },
  {
    "timestamp": "26:07",
    "timestamp_order": "383-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그리고 XML 어 NITE XML 문서를 인터페이스에 연결합니다. [/TGT]"
  },
  {
    "timestamp": "26:28",
    "timestamp_order": "388-1",
    "speaker": "Speaker_E",
    "text": "[TGT] NITE XML의 전체적인 장점은 다양한 파일을 연결한다는 것입니다. [/TGT]"
  },
  {
    "timestamp": "26:28",
    "timestamp_order": "389-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그래서 우리는 모든 발화에 대해 추가적인 XML 파일을 만들 수 있습니다. [/TGT]"
  },
  {
    "timestamp": "26:28",
    "timestamp_order": "392-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그것은 정보의 가중치, 정보 밀도에 대한 숫자가 있는 유일한 정보이고, 우리는 그것을 기존 발화에 묶고 기존 화자 변경 사항에 묶습니다. [/TGT]"
  },
  {
    "timestamp": "27:18",
    "timestamp_order": "400-1",
    "speaker": "Speaker_A",
    "text": "[TGT] 네, 각 발언에 대한 세그먼트가 나뉘어져 있다고 생각합니다. [/TGT]"
  },
  {
    "timestamp": "27:26",
    "timestamp_order": "403-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 음, 그렇지 않으면 아마 다시 검토해야 할 것 같고, 위에서 아래로 증가하는 정수를 모든 발화에 ID 같은 유형으로 추가해야 할 것 같습니다. [/TGT]"
  },
  {
    "timestamp": "27:26",
    "timestamp_order": "404-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 아니면 NITE XML ID가 어떻게 작동하는지 이해하려고 노력해야 할 수도 있고, 이 ID를 사용할 때 따라야 할 특별한 경로가 있을지도 모릅니다. [/TGT]"
  },
  {
    "timestamp": "28:39",
    "timestamp_order": "438-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그럼 우리가 가진 건 발화, 화자, 그리고 발화에 대한 가중치가 있죠. [/TGT]"
  },
  {
    "timestamp": "29:21",
    "timestamp_order": "454-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그리고 타임스탬프가 단어 수준에 있는 경우, 우리는 어떻게든 발화가 시작되는 지점에서 타임스탬프를 추출해야 합니다. [/TGT]"
  },
  {
    "timestamp": "29:28",
    "timestamp_order": "455-1",
    "speaker": "Speaker_B",
    "text": "[TGT] 세그먼트에 대한 타임스탬프가 있는데, 예를 들어 데이터를 볼 때 한 줄에 표시되는 내용이 있습니다. [/TGT]"
  },
  {
    "timestamp": "29:52",
    "timestamp_order": "463-1",
    "speaker": "Speaker_B",
    "text": "[TGT] 음, 예를 들어 II에서는 제가 일시 정지 및 지속 시간 추출에서 했던 것과 비교했습니다. [/TGT]"
  },
  {
    "timestamp": "30:20",
    "timestamp_order": "471-1",
    "speaker": "Speaker_B",
    "text": "[TGT] 음, 때로는 그렇지만 주석자들은 어떤 부분이 하나의 세그먼트이고 어떤 부분이 아닌지 결정했습니다. [/TGT]"
  },
  {
    "timestamp": "31:24",
    "timestamp_order": "495-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 하지만 지금 주제 세분화에 대해 생각하고 있는데, 그에 대한 주제 세분화는 단 하나뿐일 겁니다. [/TGT]"
  },
  {
    "timestamp": "31:36",
    "timestamp_order": "502-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 따라서 이 지연 로딩이 작동한다면, 이건 분명히 메모리에 들어가지 않을 겁니다. [/TGT]"
  },
  {
    "timestamp": "31:36",
    "timestamp_order": "503-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 왜냐하면 모든 정보가 동시에 메모리에 저장되는 건 아니니까요. [/TGT]"
  },
  {
    "timestamp": "32:11",
    "timestamp_order": "507-1",
    "speaker": "Speaker_D",
    "text": "[TGT] NITE가 임의의 새 속성 같은 걸 로드하는 것만 처리할 수 있을까요? [/TGT]"
  },
  {
    "timestamp": "32:29",
    "timestamp_order": "512-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그러면 왜 메모리에 두 개의 XML 트리가 동시에 필요한가요? [/TGT]"
  },
  {
    "timestamp": "32:32",
    "timestamp_order": "518-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 같은 양의 데이터를 두 개의 d 파일에서 가져오는 오버헤드가 하나의 파일에서 가져오는 것보다 훨씬 클지도 모른다는 생각이 들었어요. [/TGT]"
  },
  {
    "timestamp": "32:46",
    "timestamp_order": "519-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그러면 세그먼트, 음, 네, 세그먼트/발화가 이미 있는 파일에 오프라인으로 가중치를 적용하는 게 쉬울 것 같아요. [/TGT]"
  },
  {
    "timestamp": "33:10",
    "timestamp_order": "528-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 저희는 전체 인프라를 완전히 활용할 겁니다. [/TGT]"
  },
  {
    "timestamp": "33:10",
    "timestamp_order": "529-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 기본적으로 저희 프로젝트와 그들의 프로젝트 간의 가장 큰 차이점은 데이터의 다른 부분을 로드한다는 것입니다. [/TGT]"
  },
  {
    "timestamp": "33:10",
    "timestamp_order": "531-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그래서 저희는 다양한 유형의 쿼리를 실행하고 있습니다. [/TGT]"
  },
  {
    "timestamp": "33:10",
    "timestamp_order": "533-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 무엇을 로드하고 무엇을 로드하지 않는지가 중요한 것이 아니라 가중치를 기준으로 동적으로 쿼리를 선택하는 방식입니다. [/TGT]"
  },
  {
    "timestamp": "33:50",
    "timestamp_order": "537-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 아시죠, 만약 그들의 쿼리 언어가 이상해서 천만 개의 결과가 반환되고 처리할 수 없다면, 우리는 그들이 임계값을 알 수 있도록 개별 구성 요소를 작성하면 됩니다. [/TGT]"
  },
  {
    "timestamp": "34:11",
    "timestamp_order": "539-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 네, 기본적으로 너무 커지면 청크로 처리할 수 있다는 뜻이에요. [/TGT]"
  },
  {
    "timestamp": "34:11",
    "timestamp_order": "540-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 메모리에 로드하기에는 너무 커지면 그냥 전부 청크로 처리할 수 있죠. [/TGT]"
  },
  {
    "timestamp": "34:17",
    "timestamp_order": "545-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 쿼리를 통해 이 가중치와 이 가중치 위에 있는 모든 것을 제공하거나 동일한 인프라를 건너뛰고 플레이어와 디스플레이와 같은 각 개별 모듈은 여전히 모든 다른 음성, 모든 다른 부분을 받지만 현재 임계값 수준보다 낮기 때문에 이 부분은 제외한다고 말할 수 있습니다. [/TGT]"
  },
  {
    "timestamp": "34:42",
    "timestamp_order": "548-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 아마 계층적 정보 밀도도 저장해야 할 것 같습니다. [/TGT]"
  },
  {
    "timestamp": "35:01",
    "timestamp_order": "551-1",
    "speaker": "Speaker_A",
    "text": "[TGT] 네, 그렇게 하면 훨씬 더 효율적일 거예요. [/TGT]"
  },
  {
    "timestamp": "35:13",
    "timestamp_order": "558-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 회의 내 개별 주제 세그먼트에 대해 계산된 분포 측정값이 있다면 개별 발화에서 데이터를 추출할 필요가 없습니다. [/TGT]"
  },
  {
    "timestamp": "35:47",
    "timestamp_order": "565-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 글쎄요, 저는 이제 막 절반 정도 구현을 마쳤는데요. [/TGT]"
  },
  {
    "timestamp": "35:58",
    "timestamp_order": "570-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 결국 가장 높은 순위의 문구나 키워드만 넣는 건 최선이 아닐 것 같아요. [/TGT]"
  },
  {
    "timestamp": "36:11",
    "timestamp_order": "574-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그리고 그것은 인기 지역과 검색 키워드 등과 같은 것에 의해 가중치가 부여되어야 합니다. [/TGT]"
  },
  {
    "timestamp": "36:19",
    "timestamp_order": "576-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 또한 이 부분에 대해 말하자면, 마지막에 명명된 엔티티로 검토한다면, DIL을 하는 사람 중 한 명이 쓸 수 있는 명명된 엔티티 코드가 있고, 적어도 주제, 제목, 세그먼트를 찾는 것과 같은 경우, 정말 높은 DFIDF라고 불리는 명명된 엔티티를 가져오면 됩니다. [/TGT]"
  },
  {
    "timestamp": "36:51",
    "timestamp_order": "582-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그러니까 기본적으로 일반적인 계산을 너무 많이 할 필요는 없다는 뜻이죠. [/TGT]"
  },
  {
    "timestamp": "36:51",
    "timestamp_order": "583-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 하지만 특히 희소하다면 세그먼트의 내용을 설명하는 개별 명명된 엔터티를 사용하는 게 꽤 좋을 것 같아요. [/TGT]"
  },
  {
    "timestamp": "37:14",
    "timestamp_order": "587-1",
    "speaker": "Speaker_C",
    "text": "[TGT] 현재 아이디어를 구현 중이라고 하셨는데, 정확히 무엇을 계산하고 계신가요? [/TGT]"
  },
  {
    "timestamp": "38:32",
    "timestamp_order": "612-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 네, 그럼 NITE XML XML 같은 형식을 훨씬 더 자세히 이해해야 할 것 같아요. [/TGT]"
  },
  {
    "timestamp": "38:32",
    "timestamp_order": "613-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 컴퓨터실에서 같이 장시간 회의를 하면서 원하는 게 뭔지 좀 더 알게 됐으니, NITE XML에 대해 좀 더 자세히 살펴보는 게 어떨까요? [/TGT]"
  },
  {
    "timestamp": "38:48",
    "timestamp_order": "619-1",
    "speaker": "Speaker_A",
    "text": "[TGT] 회의당 몇 개씩 있고, 타임스탬프가 있고, 각 세그먼트 안에 실제 발언 세그먼트가 들어 있어요. [/TGT]"
  },
  {
    "timestamp": "39:18",
    "timestamp_order": "627-1",
    "speaker": "Speaker_A",
    "text": "[TGT] 네, 그럼 LC 세그먼트로 분할한다면 같은 형식으로 다시 넣어서 동등하게 만들면 될 것 같아요. [/TGT]"
  },
  {
    "timestamp": "39:43",
    "timestamp_order": "633-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 네, 또는 로딩과 같은 모든 요소와, 네, 통합과 데이터 로딩 처리와 같은 것들도 있습니다. [/TGT]"
  },
  {
    "timestamp": "40:49",
    "timestamp_order": "650-1",
    "speaker": "Speaker_A",
    "text": "[TGT] 음, 중요한 건 핵심적인 m 모듈을 만드는 거겠죠. [/TGT]"
  },
  {
    "timestamp": "41:44",
    "timestamp_order": "654-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그러니 어쩌면 정말 간단한 것, 예를 들어 전체 회의 내용을 표시하는 것부터 시도해 보는 게 어떨까요? [/TGT]"
  },
  {
    "timestamp": "42:02",
    "timestamp_order": "658-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 우리가 그것을 우리의 상황에 맞게 어떻게 조정할 수 있을까? [/TGT]"
  },
  {
    "timestamp": "43:28",
    "timestamp_order": "681-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 지금 당장은 NITE XML 같은 게 제대로 작동할 거라고 크게 기대하는 사람은 아무도 없겠죠? [/TGT]"
  },
  {
    "timestamp": "43:28",
    "timestamp_order": "683-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 심지어 공급망이 제대로 작동하지 않아도 디스플레이는 대부분 제가 할 수 있어요. [/TGT]"
  },
  {
    "timestamp": "44:28",
    "timestamp_order": "706-1",
    "speaker": "Speaker_A",
    "text": "[TGT] 그럼 스피커들을 모두 합친 다음 순서를 다시 지정해야 했나요? [/TGT]"
  },
  {
    "timestamp": "44:46",
    "timestamp_order": "711-1",
    "speaker": "Speaker_C",
    "text": "[TGT] 그냥 타임스탬프를 합친 다음 그에 맞춰서 정렬하면 되는 거였죠. [/TGT]"
  },
  {
    "timestamp": "45:30",
    "timestamp_order": "732-1",
    "speaker": "Speaker_C",
    "text": "[TGT] 음, 처음에 숫자가 꽤 많은데 숫자에 대한 타임스탬프가 없습니다. [/TGT]"
  },
  {
    "timestamp": "46:53",
    "timestamp_order": "762-1",
    "speaker": "Speaker_C",
    "text": "[TGT] 그런데 거기에는 타임스탬프가 주석으로 달려 있지 않네요. [/TGT]"
  },
  {
    "timestamp": "47:03",
    "timestamp_order": "767-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 어쨌든 ICSI가 그렇게 하는 데는 이유가 있겠죠. [/TGT]"
  },
  {
    "timestamp": "48:55",
    "timestamp_order": "796-1",
    "speaker": "Speaker_C",
    "text": "[TGT] 쓰레기통에 버려야 하므로 각 쓰레기통에 대한 개수만 기록될 겁니다. [/TGT]"
  },
  {
    "timestamp": "49:51",
    "timestamp_order": "806-1",
    "speaker": "Speaker_C",
    "text": "[TGT] 네, 그냥 세고, 빈도별로 정렬하는 게 꽤 쉽죠. [/TGT]"
  },
  {
    "timestamp": "51:39",
    "timestamp_order": "836-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 음, 원시 텍스트를 받으면 바로 Java 해시 맵부터 시작해서 해시 맵을 만들어서 얼마나 잘 되는지 확인해 볼 수 있을 것 같아요. [/TGT]"
  },
  {
    "timestamp": "51:55",
    "timestamp_order": "841-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 사실 당신이 정말 하고 싶은 건 DICE 기계에서 ICSI 자료의 일부를 추출하는 것뿐이에요. [/TGT]"
  },
  {
    "timestamp": "52:31",
    "timestamp_order": "848-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 음, 문제는 로컬 파일 시스템에서만 구울 수 있다는 거예요. [/TGT]"
  },
  {
    "timestamp": "52:31",
    "timestamp_order": "850-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그런데 문제는 데이터가 비피(beefy)에 있어서 로컬 임시 디렉터리로 옮겨서 거기서 구워야 한다는 거예요. [/TGT]"
  },
  {
    "timestamp": "52:58",
    "timestamp_order": "857-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 어느 날 밤에 SCP를 검토하다가 그냥 그만두고 밤새도록 그대로 둘 수도 있거든요. [/TGT]"
  },
  {
    "timestamp": "53:17",
    "timestamp_order": "865-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그런데 제가 알아낸 건, 이 하드 디스크를 사용하는 것보다 광대역 인터넷을 통해 컴퓨터에 다운로드하는 게 더 빠르다는 거예요. [/TGT]"
  },
  {
    "timestamp": "53:17",
    "timestamp_order": "866-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 하드 디스크에 접근하고 마운트하는 방식이 좀 이상해요. [/TGT]"
  },
  {
    "timestamp": "53:46",
    "timestamp_order": "878-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 네, CD-ROM에 굽거나, 네, 하드 디스크에 저장하거나, 뭐 그런 식으로요. [/TGT]"
  },
  {
    "timestamp": "54:26",
    "timestamp_order": "893-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 하지만 그건 머신의 임시 디렉토리여야 하고 SSH를 SSH 디렉토리로 옮길 수 있어야 합니다. [/TGT]"
  },
  {
    "timestamp": "54:32",
    "timestamp_order": "895-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 원격 세션에서 압축해서 같은 세션에서 SCP할 수 있나요? [/TGT]"
  },
  {
    "timestamp": "55:18",
    "timestamp_order": "904-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 게이트웨이를 통해 다른 컴퓨터로 터널링하는 방법을 아직 알아내지 못했습니다. [/TGT]"
  },
  {
    "timestamp": "55:18",
    "timestamp_order": "906-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그래서 게이트웨이 컴퓨터의 임시 디렉터리에 자료를 복사하게 됩니다. [/TGT]"
  },
  {
    "timestamp": "55:18",
    "timestamp_order": "908-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 이 글은 세부 사항일 뿐이고, 자료를 어떻게 집으로 가져오는지에 대한 내용입니다. [/TGT]"
  },
  {
    "timestamp": "57:49",
    "timestamp_order": "942-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 제가 w 같은 알고리즘을 쓰고, 원시 텍스트에서 빈도를 계산해서 해시 테이블 사전을 만드는 알고리즘을 쓰면, 원시 텍스트는 무엇이든 될 수 있어요. [/TGT]"
  },
  {
    "timestamp": "58:36",
    "timestamp_order": "947-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 음, 정보 밀도를 위해 TFIDF를 사용하고 계신가요? [/TGT]"
  },
  {
    "timestamp": "58:43",
    "timestamp_order": "948-1",
    "speaker": "Speaker_C",
    "text": "[TGT] 음, Rainbow에 구현된 것은 정보 이득인데, 그것을 어떻게 계산하는지 잘 모르겠습니다. [/TGT]"
  },
  {
    "timestamp": "58:52",
    "timestamp_order": "951-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 하지만 상황, 크기, 그리고 TFIDF를 계산할 때 문서를 어떻게 간주하는지에 따라 달라질 겁니다. [/TGT]"
  },
  {
    "timestamp": "58:57",
    "timestamp_order": "952-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 네, 저도 주파수가 필요해요. [/TGT]"
  },
  {
    "timestamp": "00:02",
    "timestamp_order": "966-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 음, 원시 주파수도 필요하죠. [/TGT]"
  },
  {
    "timestamp": "00:17",
    "timestamp_order": "970-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 모든 회의를 살펴보면, 이 알고리즘에 따라 각 회의를 하나의 문서로 간주할 수 있죠. [/TGT]"
  },
  {
    "timestamp": "00:39",
    "timestamp_order": "972-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 회의를 개별적인 것으로 보는 관념을 버리고 회의를 주제별로 세분화하여 계층적 주제 세분화를 적용하면 보다 일관된 프레임워크가 될 것이라는 생각이 점점 더 듭니다. [/TGT]"
  },
  {
    "timestamp": "01:06",
    "timestamp_order": "975-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 하지만 모든 수준에 대해 오프라인에서 TFIDF를 계산하는 것이 어려울 수도 있다고 생각했습니다. [/TGT]"
  },
  {
    "timestamp": "01:06",
    "timestamp_order": "976-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 예를 들어 분리된 세그먼트를 허용한다면 특정 시점의 맥락에서 무엇이 될지 어떻게 알 수 있을까요? [/TGT]"
  },
  {
    "timestamp": "01:06",
    "timestamp_order": "977-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 하지만 회의를 문서로 취급하여 전역적으로 처리한다면, 맥락 내의 회의만 비교하게 되므로 아마도 잘 작동할 것입니다. [/TGT]"
  },
  {
    "timestamp": "01:38",
    "timestamp_order": "978-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 잠깐, 우리가 이걸 사용해서 가중치를 계산하는 건가요? [/TGT]"
  },
  {
    "timestamp": "02:51",
    "timestamp_order": "996-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 따라서 주제별 세그먼트가 더 중요할 수 있습니다. [/TGT]"
  },
  {
    "timestamp": "03:03",
    "timestamp_order": "998-1",
    "speaker": "Speaker_C",
    "text": "[TGT] 아마도 주제별 세그먼트 수준이 단어에 비해 가장 유익한 정보를 제공하는 것 같아요. [/TGT]"
  },
  {
    "timestamp": "03:46",
    "timestamp_order": "1010-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 하지만 알고리즘 수준에서 회의를 주제로만 표현할 수 있는 방법이 있는지 여부는 의문입니다. [/TGT]"
  },
  {
    "timestamp": "03:50",
    "timestamp_order": "1012-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 네, 그냥 보고 싶은 걸 XML 파일로 쭉 모아서 회의록으로 만들면 돼요. [/TGT]"
  },
  {
    "timestamp": "04:16",
    "timestamp_order": "1018-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그러니까 기본적으로 말씀하시는 건, 임의의 양의 데이터를 가져와서 동일한 알고리즘으로 처리할 수 있다는 겁니다. [/TGT]"
  },
  {
    "timestamp": "04:16",
    "timestamp_order": "1019-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그 데이터가 개념적으로 어떤 데이터인지는 중요하지 않습니다. [/TGT]"
  },
  {
    "timestamp": "05:39",
    "timestamp_order": "1026-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 알고리즘이 이를 염두에 두고 설계된다면, 그렇게 큰 문제는 아니라고 생각합니다. [/TGT]"
  },
  {
    "timestamp": "06:32",
    "timestamp_order": "1041-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그리고 더 높은 수준을 원할 때마다 트리를 따라 올라가기만 하면 됩니다. [/TGT]"
  },
  {
    "timestamp": "08:22",
    "timestamp_order": "1064-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 수요일에 회의를 하고 구현 과정을 좀 더 자세히 살펴보고 실제로 무슨 일이 일어나고 있는지 파악할 예정입니다. [/TGT]"
  },
  {
    "timestamp": "08:40",
    "timestamp_order": "1071-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 우리는 그들의 자료에서 두 가지를 가져와서 우리가 그것을 이해하고 있는지 확인하고, 그것을 수정할 만큼 충분히 이해했는지 확인했습니다. [/TGT]"
  },
  {
    "timestamp": "08:47",
    "timestamp_order": "1073-1",
    "speaker": "Speaker_A",
    "text": "[TGT] 거기에 모든 코드를 넣어둘 수 있는 그런 게 있어야 하지 않을까요? [/TGT]"
  },
  {
    "timestamp": "09:23",
    "timestamp_order": "1087-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 지금 제가 기가바이트씩 쌓이는 곳이 바로 거기거든요. [/TGT]"
  },
  {
    "timestamp": "10:06",
    "timestamp_order": "1101-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그런데 ICSI 자료 사본을 받아도 될까요? [/TGT]"
  },
  {
    "timestamp": "11:08",
    "timestamp_order": "1118-1",
    "speaker": "Speaker_B",
    "text": "[TGT] 왜냐하면 제 생각에는 제가 스피커 추출을 위해 한 것과 실제로 매우 유사하고, 각 회의에 대해 fr에서 um까지라는 파일을 얻으려면 두 줄의 코드를 변경해야 할 것 같습니다. [/TGT]"
  },
  {
    "timestamp": "12:51",
    "timestamp_order": "1139-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 방금 깨달은 건, 사실상 모든 용도에 대해 서로 다른 시리즈를 완전히 분리해서 관리하면 안 된다는 거예요. [/TGT]"
  },
  {
    "timestamp": "13:02",
    "timestamp_order": "1142-1",
    "speaker": "Speaker_E",
    "text": "[TGT] ICSI 코퍼스는 하나의 회의 시리즈가 아니라, 완전히 다른 목적으로 모인 여러 사람이 모인 여러 회의 시리즈입니다. [/TGT]"
  },
  {
    "timestamp": "13:12",
    "timestamp_order": "1144-1",
    "speaker": "Speaker_B",
    "text": "[TGT] 네, 제가 드릴 수 있는 건 회의마다 파일 하나씩입니다. [/TGT]"
  },
  {
    "timestamp": "13:23",
    "timestamp_order": "1150-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 하지만 우리가 병합하는 모든 것이 ICSI 전체가 아니라 개별 시리즈라는 점에 주의하시기 바랍니다. [/TGT]"
  },
  {
    "timestamp": "14:52",
    "timestamp_order": "1166-1",
    "speaker": "Speaker_B",
    "text": "[TGT] 하지만 각 회의의 시작 시간을 0으로 설정하면, 마지막 두 번째 시간을 다음 회의에 더하는 식으로 모든 것을 합칠 수 있을 겁니다. [/TGT]"
  },
  {
    "timestamp": "14:52",
    "timestamp_order": "1167-1",
    "speaker": "Speaker_B",
    "text": "[TGT] 하지만 그러면 누가 어떤 채널에 설정되었는지, 그리고 누가 설정했는지에 대한 정보를 변경해야 할 겁니다. [/TGT]"
  },
  {
    "timestamp": "18:27",
    "timestamp_order": "1225-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 언제쯤이면 이미 만들어진 주제 세분화나 이미 만들어진 도구를 이용한 기본적인 세분화가 가능해질 거라고 생각하시나요? [/TGT]"
  },
  {
    "timestamp": "19:35",
    "timestamp_order": "1249-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 네, 아마 모든 시리즈의 데이터를 처리해서 어떤 시리즈가 프레젠테이션에 가장 적합한지 확인할 수 있을 것 같아요. [/TGT]"
  },
  {
    "timestamp": "20:16",
    "timestamp_order": "1259-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 정보 밀도 문제가 해결될 때까지 주파수와 함께 사용하면 될 것 같아요. [/TGT]"
  },
  {
    "timestamp": "21:13",
    "timestamp_order": "1289-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 그러면 숫자를 걸러내는 필터 같은 걸 구현할 것 같아요. [/TGT]"
  },
  {
    "timestamp": "22:01",
    "timestamp_order": "1298-1",
    "speaker": "Speaker_D",
    "text": "[TGT] Java로 작업하는 경우, 출력을 직렬화하고 파일에 쓸 수 있나요? [/TGT]"
  },
  {
    "timestamp": "22:01",
    "timestamp_order": "1299-1",
    "speaker": "Speaker_D",
    "text": "[TGT] Java로 작업하는 경우, 사전을 직렬화하고 파일에 쓸 수 있나요? [/TGT]"
  },
  {
    "timestamp": "22:35",
    "timestamp_order": "1313-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 그래서 데이터 구조를 다시 구축하면 됩니다. [/TGT]"
  },
  {
    "timestamp": "23:02",
    "timestamp_order": "1322-1",
    "speaker": "Speaker_E",
    "text": "[TGT] serialise 명령이 있는데, 그걸 사용하면 엄청난 양의 데이터가 쌓이는 것 같아요. [/TGT]"
  },
  {
    "timestamp": "23:32",
    "timestamp_order": "1327-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 오늘 밤에는 TFIDF 요약기를 좀 더 다듬거나 오디오 작업을 해보겠습니다. [/TGT]"
  },
  {
    "timestamp": "24:10",
    "timestamp_order": "1341-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 하지만 다음 주에 원시적인 것이 작동하는 시연을 하는 게 유용할 것이라는 데에 우리 의견이 일치했다고 하지 않았나요? [/TGT]"
  },
  {
    "timestamp": "24:19",
    "timestamp_order": "1343-1",
    "speaker": "Speaker_A",
    "text": "[TGT] 네, 그는 우리가 초기 프로토타입을 만들어 볼 수 있을 거라고 제안했어요. [/TGT]"
  },
  {
    "timestamp": "24:58",
    "timestamp_order": "1349-1",
    "speaker": "Speaker_D",
    "text": "[TGT] 제 생각에는 우리가 직접 지정해야 했기 때문에 우리가 해야 하는 대부분의 작업의 사양에 초점을 맞추지 않은 것 같습니다. [/TGT]"
  },
  {
    "timestamp": "25:06",
    "timestamp_order": "1350-1",
    "speaker": "Speaker_E",
    "text": "[TGT] 네, 하지만 지금은 구현 단계이기도 합니다. [/TGT]"
  }
]