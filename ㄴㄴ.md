# 📊 DdalKkak 데이터베이스 설계서

---

## 📋 개요

DdalKkak은 AI 기반 회의 전사 및 업무 자동화 플랫폼으로, WhisperX STT 엔진과 Qwen3-14B LLM을 활용하여 회의 내용을 자동으로 전사하고 업무를 추출하는 Multi-tenant SaaS 서비스입니다.

### 프로젝트 정보
- **프로젝트명**: DdalKkak (똑똑)
- **데이터베이스**: PostgreSQL 15
- **아키텍처**: Multi-tenant SaaS
- **주요 기능**: 회의 전사, AI 업무 추출, 외부 연동

---

## 1. 채택한 모델링 방법론

### 1.1 데이터 모델링 접근법
- **하향식 접근법**: 비즈니스 요구사항에서 시작하여 물리적 구현까지
- **개체-관계 모델(ERD)**: 엔터티 중심의 논리적 설계
- **정규화 기반**: 제3정규형까지 적용, 성능 고려 시 비정규화

### 1.2 설계 방법론
- **Agile Data Modeling**: 반복적 개선과 점진적 확장
- **Domain-Driven Design**: 비즈니스 도메인 중심 설계
- **JSONB 혼합 모델**: 관계형 + NoSQL 장점 결합

### 1.3 설계 도구
- **DB Diagram**: 시각적 ERD 설계
- **Prisma Schema**: 코드 기반 스키마 정의
- **Migration-First**: 스키마 변경 이력 관리

---

## 2. 논리 데이터 모델

### 2.1 엔터티 목록

| 엔터티명 | 영문명 | 설명 | 주요 속성 |
|---------|--------|------|----------|
| 테넌트 | tenants | Multi-tenant 격리 단위 | id, name, slug |
| 사용자 | users | 시스템 사용자 | id, tenant_id, email, role |
| 회의 | meetings | 회의 정보 + STT + AI 결과 | id, title, transcript_text, ai_summary |
| 업무 | tasks | AI 생성 업무 + 수동 업무 | id, title, status, is_ai_generated |
| 실시간세션 | realtime_sessions | 실시간 STT 세션 | id, socket_id, status |
| 외부연동 | integrations | 외부 서비스 연동 설정 | id, service_type, access_token |

### 2.2 주요 엔터티 상세 정의

#### 🏢 2.2.1 테넌트 (tenants)
> **핵심 역할**: Multi-tenant SaaS 구조의 격리 단위

| 구분 | 내용 |
|------|------|
| **🎯 목적** | 조직별 데이터 완전 격리 및 독립 운영 환경 제공 |
| **🔑 핵심 속성** | • `id` - 테넌트 고유 식별자 (UUID)<br>• `name` - 조직명<br>• `slug` - URL 식별자 (고유) |
| **📋 비즈니스 규칙** | • 테넌트별 완전한 데이터 격리<br>• slug는 URL에 사용되므로 영숫자만 허용<br>• 테넌트 삭제 시 모든 하위 데이터 연쇄 삭제 |
| **🔗 관계** | → users (1:N)<br>→ meetings (1:N)<br>→ tasks (1:N) |

---

#### 👤 2.2.2 사용자 (users)
> **핵심 역할**: 시스템 접근 주체 관리 및 권한 제어

| 구분 | 내용 |
|------|------|
| **🎯 목적** | 테넌트별 사용자 관리 및 역할 기반 접근 제어 |
| **🔑 핵심 속성** | • `id` - 사용자 고유 식별자 (UUID)<br>• `tenant_id` - 소속 테넌트 (FK)<br>• `email` - 로그인 계정<br>• `role` - 권한 등급 (OWNER/ADMIN/MEMBER)<br>• `slack_user_id` - Slack 연동 ID |
| **📋 비즈니스 규칙** | • 테넌트 내에서 email 고유<br>• OWNER는 테넌트당 1명만 가능<br>• 사용자 삭제 시 업무 담당자는 null 처리 |
| **🔗 관계** | ← tenants (N:1)<br>→ meetings (1:N, host)<br>→ tasks (1:N, assignee) |

---

#### 🎙️ 2.2.3 회의 (meetings)
> **핵심 역할**: 회의 정보와 STT/AI 분석 결과 통합 관리

| 구분 | 내용 |
|------|------|
| **🎯 목적** | 회의 메타데이터부터 AI 분석 결과까지 원스톱 관리 |
| **🔑 핵심 속성** | • `id` - 회의 고유 식별자 (UUID)<br>• `title` - 회의 제목<br>• `transcript_text` - STT 결과 텍스트<br>• `transcript_segments` - 화자별 세그먼트 (JSONB)<br>• `ai_summary` - AI 생성 요약<br>• `ai_action_items` - AI 추출 업무 (JSONB) |
| **📋 비즈니스 규칙** | • STT 처리 완료 후 AI 분석 시작<br>• 결과는 JSONB로 유연하게 저장<br>• 회의 삭제 시 연결된 업무는 orphan 처리 |
| **🔗 관계** | ← tenants (N:1)<br>← users (N:1, host)<br>→ tasks (1:N, optional) |

---

#### ✅ 2.2.4 업무 (tasks)
> **핵심 역할**: AI 추출 업무와 수동 생성 업무 통합 관리

| 구분 | 내용 |
|------|------|
| **🎯 목적** | 회의에서 추출된 AI 업무와 수동 생성 업무의 통합 관리 |
| **🔑 핵심 속성** | • `id` - 업무 고유 식별자 (UUID)<br>• `meeting_id` - 출처 회의 (FK, nullable)<br>• `title` - 업무 제목<br>• `status` - 진행 상태 (TODO/IN_PROGRESS/DONE)<br>• `is_ai_generated` - AI 생성 여부 |
| **📋 비즈니스 규칙** | • AI 생성 업무는 meeting_id 필수<br>• 수동 생성 업무는 meeting_id null 가능<br>• 담당자는 같은 테넌트 내 사용자만 가능 |
| **🔗 관계** | ← tenants (N:1)<br>← meetings (N:1, optional)<br>← users (N:1, assignee) |

---

#### 🔄 2.2.5 실시간세션 (realtime_sessions)
> **핵심 역할**: 실시간 STT 처리 세션 관리

| 구분 | 내용 |
|------|------|
| **🎯 목적** | WebSocket 기반 실시간 음성 인식 세션 추적 |
| **🔑 핵심 속성** | • `id` - 세션 고유 식별자 (UUID)<br>• `socket_id` - WebSocket 연결 ID<br>• `status` - 세션 상태 (ACTIVE/ENDED)<br>• `started_at` - 세션 시작 시간<br>• `ended_at` - 세션 종료 시간 |
| **📋 비즈니스 규칙** | • 세션당 하나의 WebSocket 연결<br>• 세션 종료 시 회의 데이터 생성<br>• 비정상 종료 시 자동 정리 |
| **🔗 관계** | ← tenants (N:1)<br>← users (N:1, host)<br>→ meetings (1:1, optional) |

---

#### 🔌 2.2.6 외부연동 (integrations)
> **핵심 역할**: 외부 서비스 연동 설정 관리

| 구분 | 내용 |
|------|------|
| **🎯 목적** | Slack, Teams 등 외부 서비스 연동 정보 보안 관리 |
| **🔑 핵심 속성** | • `id` - 연동 고유 식별자 (UUID)<br>• `service_type` - 서비스 타입 (SLACK/TEAMS/NOTION)<br>• `access_token` - 암호화된 접근 토큰<br>• `is_active` - 활성 상태 |
| **📋 비즈니스 규칙** | • 테넌트당 서비스별 하나의 연동만 허용<br>• access_token은 암호화 저장<br>• 연동 해제 시 관련 기능 자동 비활성화 |
| **🔗 관계** | ← tenants (N:1) |

---

#### 🔄 엔터티 간 관계 흐름도

```
🏢 tenants (테넌트)
├── 👤 users (사용자) 
│   ├── 🎙️ meetings (회의 - 주최자)
│   │   └── ✅ tasks (업무 - AI 추출)
│   ├── ✅ tasks (업무 - 담당자)
│   └── 🔄 realtime_sessions (실시간 세션)
└── 🔌 integrations (외부 연동)
```

**주요 데이터 흐름:**
1. **실시간 STT**: `realtime_sessions` → `meetings` (transcript 생성)
2. **AI 분석**: `meetings` → `tasks` (AI 업무 추출)
3. **외부 연동**: `integrations` → `meetings/tasks` (Slack 알림 등)

---

## 3. 물리 데이터 모델

### 3.1 테이블 정의서

#### 3.1.1 tenants 테이블
| 컬럼명 | 데이터타입 | 제약조건 | 기본값 | 설명 |
|--------|------------|----------|--------|------|
| id | UUID | PK, NOT NULL | gen_random_uuid() | 테넌트 ID |
| name | VARCHAR(100) | NOT NULL | - | 조직명 |
| slug | VARCHAR(50) | UNIQUE, NOT NULL | - | URL 식별자 |
| created_at | TIMESTAMP | NOT NULL | NOW() | 생성일시 |
| updated_at | TIMESTAMP | NOT NULL | NOW() | 수정일시 |

#### 3.1.2 users 테이블
| 컬럼명 | 데이터타입 | 제약조건 | 기본값 | 설명 |
|--------|------------|----------|--------|------|
| id | UUID | PK, NOT NULL | gen_random_uuid() | 사용자 ID |
| tenant_id | UUID | FK, NOT NULL | - | 테넌트 ID |
| email | VARCHAR(255) | NOT NULL | - | 이메일 |
| name | VARCHAR(100) | NOT NULL | - | 사용자명 |
| role | user_role_enum | NOT NULL | 'MEMBER' | 권한 |
| slack_user_id | VARCHAR(50) | NULL | - | Slack 사용자 ID |
| created_at | TIMESTAMP | NOT NULL | NOW() | 생성일시 |
| updated_at | TIMESTAMP | NOT NULL | NOW() | 수정일시 |

#### 3.1.3 meetings 테이블
| 컬럼명 | 데이터타입 | 제약조건 | 기본값 | 설명 |
|--------|------------|----------|--------|------|
| id | UUID | PK, NOT NULL | gen_random_uuid() | 회의 ID |
| tenant_id | UUID | FK, NOT NULL | - | 테넌트 ID |
| title | VARCHAR(200) | NOT NULL | - | 회의 제목 |
| host_id | UUID | FK, NOT NULL | - | 주최자 ID |
| audio_file_url | TEXT | NULL | - | 오디오 파일 URL |
| audio_duration | INTEGER | NULL | - | 오디오 길이(초) |
| stt_status | stt_status_enum | NOT NULL | 'PENDING' | STT 처리 상태 |
| transcript_text | TEXT | NULL | - | 전사 텍스트 |
| transcript_segments | JSONB | NULL | - | 화자별 세그먼트 |
| speaker_labels | JSONB | NULL | - | 화자 라벨 |
| ai_summary | TEXT | NULL | - | AI 요약 |
| ai_action_items | JSONB | NULL | - | AI 추출 업무 |
| slack_message_ts | VARCHAR(50) | NULL | - | Slack 메시지 ID |
| created_at | TIMESTAMP | NOT NULL | NOW() | 생성일시 |
| updated_at | TIMESTAMP | NOT NULL | NOW() | 수정일시 |

#### 3.1.4 tasks 테이블
| 컬럼명 | 데이터타입 | 제약조건 | 기본값 | 설명 |
|--------|------------|----------|--------|------|
| id | UUID | PK, NOT NULL | gen_random_uuid() | 업무 ID |
| tenant_id | UUID | FK, NOT NULL | - | 테넌트 ID |
| meeting_id | UUID | FK, NULL | - | 회의 ID |
| title | VARCHAR(200) | NOT NULL | - | 업무 제목 |
| description | TEXT | NULL | - | 업무 상세 |
| status | task_status_enum | NOT NULL | 'TODO' | 진행 상태 |
| assignee_id | UUID | FK, NULL | - | 담당자 ID |
| due_date | TIMESTAMP | NULL | - | 마감일 |
| is_ai_generated | BOOLEAN | NOT NULL | FALSE | AI 생성 여부 |
| created_at | TIMESTAMP | NOT NULL | NOW() | 생성일시 |
| updated_at | TIMESTAMP | NOT NULL | NOW() | 수정일시 |

#### 3.1.5 realtime_sessions 테이블
| 컬럼명 | 데이터타입 | 제약조건 | 기본값 | 설명 |
|--------|------------|----------|--------|------|
| id | UUID | PK, NOT NULL | gen_random_uuid() | 세션 ID |
| tenant_id | UUID | FK, NOT NULL | - | 테넌트 ID |
| meeting_id | UUID | FK, NULL | - | 회의 ID |
| host_id | UUID | FK, NOT NULL | - | 주최자 ID |
| socket_id | VARCHAR(100) | NOT NULL | - | WebSocket ID |
| status | session_status_enum | NOT NULL | 'ACTIVE' | 세션 상태 |
| started_at | TIMESTAMP | NOT NULL | NOW() | 시작일시 |
| ended_at | TIMESTAMP | NULL | - | 종료일시 |

#### 3.1.6 integrations 테이블
| 컬럼명 | 데이터타입 | 제약조건 | 기본값 | 설명 |
|--------|------------|----------|--------|------|
| id | UUID | PK, NOT NULL | gen_random_uuid() | 연동 ID |
| tenant_id | UUID | FK, NOT NULL | - | 테넌트 ID |
| service_type | integration_service_enum | NOT NULL | - | 서비스 타입 |
| access_token | TEXT | NULL | - | 접근 토큰 |
| is_active | BOOLEAN | NOT NULL | TRUE | 활성 상태 |
| created_at | TIMESTAMP | NOT NULL | NOW() | 생성일시 |
| updated_at | TIMESTAMP | NOT NULL | NOW() | 수정일시 |

### 3.2 제약 조건 명세

#### 🔑 3.2.1 기본키 제약조건
> **모든 테이블에 UUID 기반 기본키 적용**

| 테이블 | 기본키 | 제약 이름 | 설명 |
|--------|--------|-----------|------|
| 🏢 tenants | `id` | pk_tenants | 테넌트 고유 식별자 |
| 👤 users | `id` | pk_users | 사용자 고유 식별자 |
| 🎙️ meetings | `id` | pk_meetings | 회의 고유 식별자 |
| ✅ tasks | `id` | pk_tasks | 업무 고유 식별자 |
| 🔄 realtime_sessions | `id` | pk_realtime_sessions | 실시간 세션 고유 식별자 |
| 🔌 integrations | `id` | pk_integrations | 외부 연동 고유 식별자 |

---

#### 🔗 3.2.2 외래키 제약조건

**Multi-tenant 격리 외래키**
| 자식 테이블 | 외래키 | 참조 테이블 | 삭제 정책 | 목적 |
|-------------|--------|-------------|-----------|------|
| 👤 users | `tenant_id` | 🏢 tenants | CASCADE | 테넌트 삭제 시 사용자 자동 삭제 |
| 🎙️ meetings | `tenant_id` | 🏢 tenants | CASCADE | 테넌트 삭제 시 회의 자동 삭제 |
| ✅ tasks | `tenant_id` | 🏢 tenants | CASCADE | 테넌트 삭제 시 업무 자동 삭제 |

**엔터티 간 관계 외래키**
| 자식 테이블 | 외래키 | 참조 테이블 | 삭제 정책 | 목적 |
|-------------|--------|-------------|-----------|------|
| 🎙️ meetings | `host_id` | 👤 users | RESTRICT | 회의 주최자 삭제 방지 |
| ✅ tasks | `meeting_id` | 🎙️ meetings | SET NULL | 회의 삭제 시 업무는 독립적 유지 |
| ✅ tasks | `assignee_id` | 👤 users | SET NULL | 담당자 삭제 시 업무는 미할당 상태 |

---

#### ✨ 3.2.3 고유성 제약조건

| 테이블 | 고유 조건 | 목적 | 비즈니스 의미 |
|--------|-----------|------|---------------|
| 🏢 tenants | `slug` | URL 중복 방지 | 각 조직은 고유한 URL 보유 |
| 👤 users | `tenant_id` + `email` | 테넌트 내 이메일 중복 방지 | 같은 조직 내에서는 이메일 고유 |
| 🔌 integrations | `tenant_id` + `service_type` | 서비스별 단일 연동 | 조직당 Slack 연동은 하나만 |

---

#### ✅ 3.2.4 체크 제약조건

| 테이블 | 검증 조건 | 목적 | 허용 형태 |
|--------|-----------|------|-----------|
| 🏢 tenants | `slug` 형식 | URL 안전성 | 영소문자, 숫자, 하이픈만 (예: `company-abc`) |
| 👤 users | `email` 형식 | 이메일 유효성 | 표준 이메일 형식 (예: `user@company.com`) |
| 🎙️ meetings | `audio_duration` 범위 | 음성 길이 검증 | 0초 초과 또는 NULL |

---

## 4. 데이터 정합성 및 무결성 관리 방안

### 4.1 중복 방지 전략

#### 🛡️ 4.1.1 테넌트 레벨 중복 방지
> **Multi-tenant 구조에서 데이터 격리와 중복 방지**

| 영역 | 중복 방지 규칙 | 범위 | 예시 |
|------|---------------|------|------|
| **🏢 조직 식별자** | slug 전역 고유 | 시스템 전체 | `company-a`, `company-b` |
| **👤 사용자 계정** | 이메일 테넌트 내 고유 | 테넌트 내부 | `user@company.com` (A조직), `user@company.com` (B조직) 가능 |
| **🔌 외부 연동** | 서비스별 단일 연동 | 테넌트 내부 | 조직당 Slack 연동 1개, Teams 연동 1개 |

#### 🔄 4.1.2 중복 검증 흐름도

```
📝 사용자 생성 요청
    ↓
🔍 테넌트 내 이메일 중복 검사
    ↓
❌ 중복 발견 → 오류 반환
    ↓
✅ 중복 없음 → 사용자 생성 진행
```

#### 📋 4.1.3 중복 방지 정책 요약

| 정책 유형 | 적용 대상 | 검증 시점 | 처리 방법 |
|-----------|-----------|-----------|-----------|
| **데이터베이스 제약** | 모든 고유 필드 | 데이터 저장 시 | 자동 오류 반환 |
| **애플리케이션 검증** | 복합 조건 | 요청 처리 시 | 사전 검증 후 진행 |
| **비즈니스 규칙** | 연동 설정 등 | 기능 실행 시 | 조건부 허용/거부 |

### 4.2 정규화 수준

#### 4.2.1 제3정규형 (3NF) 적용
- **테넌트-사용자-회의-업무**: 명확한 정규화 구조
- **함수적 종속성**: 모든 비키 속성이 기본키에만 종속
- **이행적 종속성 제거**: 중간 테이블을 통한 관계 정리

#### 4.2.2 성능을 위한 비정규화
- **meetings 테이블**: STT + AI 결과 통합 저장
- **JSONB 활용**: 복잡한 구조를 하나의 컬럼에 저장
- **중복 허용**: slack_user_id 등 빠른 조회를 위한 중복

### 4.3 애플리케이션 레벨 검증

#### ⚡ 4.3.1 검증 계층 구조
> **데이터베이스 제약 + 애플리케이션 로직 = 완전한 데이터 무결성**

```
🔒 3단계 검증 체계
├── 1️⃣ 스키마 검증 (Prisma)
│   ├── 데이터 타입 검증
│   ├── 필수 필드 검증  
│   └── 기본 제약 조건
├── 2️⃣ 비즈니스 로직 검증
│   ├── 조건부 필수 필드
│   ├── 테넌트 격리 검증
│   └── 상태 전환 규칙
└── 3️⃣ 데이터베이스 제약
    ├── 외래키 무결성
    ├── 고유성 제약
    └── 체크 제약
```

#### 📋 4.3.2 주요 검증 규칙

| 검증 영역 | 규칙 | 예시 상황 | 처리 방법 |
|-----------|------|-----------|-----------|
| **🤖 AI 업무 생성** | AI 생성 업무는 `meeting_id` 필수 | 회의 없이 AI 업무 생성 시도 | 오류 반환 |
| **👤 담당자 할당** | 담당자는 같은 테넌트 내 사용자만 | 타 조직 사용자를 담당자로 지정 | 사전 검증 후 차단 |
| **🏢 테넌트 격리** | 모든 데이터는 테넌트별 격리 | 타 조직 데이터 접근 시도 | 권한 검증 후 차단 |
| **📊 상태 전환** | 업무 상태 변경 시 조건 확인 | 종료된 회의의 업무 수정 | 조건부 허용 |

#### 🔄 4.3.3 검증 실행 흐름

```
📝 요청 접수
    ↓
🔍 스키마 검증 (자동)
    ↓
⚡ 비즈니스 로직 검증
    ↓
💾 데이터베이스 저장
    ↓
🛡️ 제약 조건 최종 검증
    ↓
✅ 성공 또는 ❌ 오류 반환
```

#### 🎯 4.3.4 핵심 검증 시나리오

| 시나리오 | 검증 포인트 | 성공 조건 | 실패 시 처리 |
|----------|-------------|-----------|-------------|
| **사용자 생성** | 이메일 중복, 테넌트 유효성 | 테넌트 내 이메일 미중복 | 중복 오류 메시지 |
| **회의 생성** | 주최자 권한, 파일 형식 | 유효 사용자, 지원 형식 | 권한/형식 오류 |
| **업무 할당** | 담당자 소속, 회의 연결성 | 같은 테넌트, 유효 회의 | 할당 불가 메시지 |
| **외부 연동** | 중복 연동, 토큰 유효성 | 서비스별 단일 연동 | 기존 연동 해제 안내 |

### 4.4 예외 데이터 처리 전략

#### 🔄 4.4.1 Soft Delete 정책
> **중요 데이터는 논리적 삭제로 안전 보장**

| 테이블 | Soft Delete 적용 | 이유 | 복구 시나리오 |
|--------|------------------|------|---------------|
| 👤 users | ✅ 적용 | 업무 추적성 | 퇴사자 업무 이력 조회 |
| 🎙️ meetings | ✅ 적용 | 회의록 보존 | 실수 삭제 후 복구 |
| ✅ tasks | ✅ 적용 | 프로젝트 기록 | 완료 업무 통계 분석 |
| 🏢 tenants | ❌ 물리 삭제 | 완전 격리 | - |
| 🔄 realtime_sessions | ❌ 물리 삭제 | 임시 데이터 | - |

#### 🛡️ 4.4.2 데이터 복구 전략

**백업 계층**
```
🗄️ 데이터 보호 체계
├── 📊 실시간 복제 (Hot Standby)
├── 📅 일일 전체 백업 (Full Backup)
├── ⏰ 시간별 증분 백업 (Incremental)
└── 🕰️ Point-in-time Recovery (PITR)
```

| 복구 유형 | 대상 상황 | 복구 시간 | 데이터 손실 |
|-----------|-----------|-----------|-------------|
| **Hot Standby** | 서버 장애 | < 1분 | 없음 |
| **일일 백업** | 데이터 손상 | < 30분 | 최대 1일 |
| **증분 백업** | 부분 손실 | < 10분 | 최대 1시간 |
| **PITR** | 특정 시점 복구 | < 20분 | 없음 |

#### ⚠️ 4.4.3 오류 데이터 격리

**격리 전략**
| 오류 유형 | 격리 방법 | 보관 기간 | 처리 방안 |
|-----------|-----------|-----------|-----------|
| **STT 실패** | `meetings_error` 테이블 | 30일 | 재처리 또는 수동 전사 |
| **AI 분석 실패** | `ai_error_log` 테이블 | 7일 | 재분석 또는 수동 업무 생성 |
| **연동 실패** | `integration_error_log` | 3일 | 토큰 갱신 또는 재연동 |
| **데이터 오염** | `quarantine` 스키마 | 90일 | 검토 후 정제 또는 삭제 |

**격리 데이터 구조**
```
🚨 오류 데이터 관리
├── 📋 원본 데이터 백업
├── 🔍 오류 원인 기록  
├── 📅 발생 시점 추적
└── 🔧 처리 상태 관리
```

#### 🎯 4.4.4 예외 처리 시나리오

| 예외 상황 | 감지 방법 | 자동 처리 | 수동 개입 |
|-----------|-----------|-----------|-----------|
| **회의 파일 손상** | STT 처리 실패 | 격리 테이블 이동 | 파일 복구 또는 재업로드 |
| **AI 응답 오류** | JSON 파싱 실패 | 에러 로그 기록 | 프롬프트 조정 후 재실행 |
| **외부 API 장애** | HTTP 오류 코드 | 재시도 큐 등록 | 서비스 복구 후 배치 처리 |
| **사용자 권한 오남용** | 비정상 접근 패턴 | 계정 임시 차단 | 관리자 검토 후 조치 |

---

## 5. 변경 이력 및 적용 전략

### 5.1 변경 이력

#### 5.1.1 버전 1.0.0 (2025-01-08)
- **초기 스키마**: 6개 핵심 테이블 생성
- **기본 제약조건**: PK, FK, UNIQUE 제약 적용
- **인덱스**: Multi-tenant 격리용 기본 인덱스

#### 5.1.2 예정 변경사항 (v1.1.0)
- **성능 최적화**: JSONB 인덱스 추가
- **감사 로그**: 중요 테이블에 audit trail 추가
- **파티셔닝**: meetings 테이블 월별 파티셔닝

### 5.2 적용 절차

#### 5.2.1 마이그레이션 관리
```bash
# Prisma를 통한 마이그레이션
npx prisma migrate dev --name initial_schema
npx prisma migrate deploy  # 프로덕션 적용
```

#### 5.2.2 배포 절차
1. **개발환경 검증**: 로컬에서 마이그레이션 테스트
2. **스테이징 적용**: 실제 데이터로 검증
3. **백업 수행**: 프로덕션 배포 전 전체 백업
4. **프로덕션 적용**: 점검 시간에 배포
5. **후속 검증**: 데이터 무결성 검증

#### 5.2.3 롤백 계획
```sql
-- 긴급 롤백을 위한 백업 테이블
CREATE TABLE schema_backup AS SELECT * FROM information_schema.tables;
-- 마이그레이션 실패 시 이전 백업으로 복원
```

---

## 📋 인덱스 및 성능 최적화

### 필수 인덱스
```sql
-- Multi-tenant 격리용 기본 인덱스
CREATE INDEX idx_users_tenant_id ON users(tenant_id);
CREATE INDEX idx_meetings_tenant_id ON meetings(tenant_id);
CREATE INDEX idx_tasks_tenant_id ON tasks(tenant_id);
CREATE INDEX idx_realtime_sessions_tenant_id ON realtime_sessions(tenant_id);
CREATE INDEX idx_integrations_tenant_id ON integrations(tenant_id);

-- 성능 최적화 인덱스
CREATE INDEX idx_meetings_status ON meetings(stt_status);
CREATE INDEX idx_tasks_assignee ON tasks(assignee_id);
CREATE INDEX idx_realtime_sessions_socket ON realtime_sessions(socket_id);

-- 복합 인덱스
CREATE INDEX idx_tasks_tenant_status ON tasks(tenant_id, status);
CREATE INDEX idx_meetings_tenant_host ON meetings(tenant_id, host_id);
CREATE INDEX idx_users_tenant_email ON users(tenant_id, email);
```

### JSONB 인덱스 (향후 적용)
```sql
-- AI 분석 결과 검색용
CREATE INDEX idx_meetings_ai_actions ON meetings 
USING GIN ((ai_action_items));

-- 화자별 검색용
CREATE INDEX idx_meetings_speakers ON meetings 
USING GIN ((speaker_labels));
```

---

## 🔒 보안 및 권한 관리

### Row Level Security (RLS) 정책
```sql
-- 테넌트별 데이터 격리
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
CREATE POLICY tenant_isolation_users ON users
    FOR ALL TO authenticated_user
    USING (tenant_id = current_setting('app.current_tenant_id')::uuid);

ALTER TABLE meetings ENABLE ROW LEVEL SECURITY;
CREATE POLICY tenant_isolation_meetings ON meetings
    FOR ALL TO authenticated_user  
    USING (tenant_id = current_setting('app.current_tenant_id')::uuid);
```

### 암호화 전략
```sql
-- 민감 정보 암호화 저장
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- access_token 암호화 함수
CREATE OR REPLACE FUNCTION encrypt_token(token TEXT) 
RETURNS TEXT AS $$
BEGIN
    RETURN encode(encrypt(token::bytea, current_setting('app.encryption_key'), 'aes'), 'base64');
END;
$$ LANGUAGE plpgsql;
```

---

## 📊 모니터링 및 성능 지표

### 핵심 성능 지표 (KPI)
- **쿼리 응답시간**: 평균 < 100ms
- **동시 접속자**: 최대 1,000명 지원
- **STT 처리량**: 시간당 100시간 분량
- **데이터베이스 크기**: 월 10GB 증가 예상

### 모니터링 쿼리
```sql
-- 테넌트별 사용량 모니터링
SELECT 
    t.name,
    COUNT(DISTINCT u.id) as user_count,
    COUNT(DISTINCT m.id) as meeting_count,
    COUNT(DISTINCT tk.id) as task_count
FROM tenants t
LEFT JOIN users u ON t.id = u.tenant_id
LEFT JOIN meetings m ON t.id = m.tenant_id
LEFT JOIN tasks tk ON t.id = tk.tenant_id
GROUP BY t.id, t.name;

-- 성능 모니터링
SELECT 
    schemaname,
    tablename,
    attname,
    n_distinct,
    correlation
FROM pg_stats 
WHERE tablename IN ('users', 'meetings', 'tasks');
```

---

## 🚀 확장성 및 향후 계획

### 현재 설계의 확장 포인트
1. **JSONB 확장**: 새로운 AI 분석 결과 추가
2. **외부 연동**: 새로운 서비스 타입 추가
3. **권한 확장**: 더 세분화된 역할 정의
4. **성능 향상**: 파티셔닝 및 샤딩 적용

### 단계별 확장 계획

#### Phase 1: MVP (현재)
- 6개 핵심 테이블로 기본 기능 구현
- Slack 연동 우선 지원
- 기본 Multi-tenant 구조

#### Phase 2: 기능 확장 (3개월 후)
```sql
-- 알림 테이블 추가
CREATE TABLE notifications (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id),
    user_id UUID NOT NULL REFERENCES users(id),
    type VARCHAR(50) NOT NULL,
    message TEXT NOT NULL,
    is_read BOOLEAN DEFAULT FALSE,
    created_at TIMESTAMP DEFAULT NOW()
);

-- 사용량 통계 테이블 추가  
CREATE TABLE usage_stats (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    tenant_id UUID NOT NULL REFERENCES tenants(id),
    date DATE NOT NULL,
    meetings_count INTEGER DEFAULT 0,
    audio_minutes INTEGER DEFAULT 0,
    ai_requests INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT NOW()
);
```

#### Phase 3: 엔터프라이즈 (6개월 후)
- Read Replica 구성
- 월별 파티셔닝 적용
- 고급 분석 기능
- 감사 로그 시스템

### 마이그레이션 전략
```bash
# 개발 → 스테이징 → 프로덕션 순차 배포
npm run db:backup          # 백업 수행
npm run db:migrate:deploy  # 마이그레이션 실행
npm run db:verify          # 무결성 검증
```

---

## 📝 결론

본 데이터베이스 설계서는 DdalKkak AI 회의 전사 플랫폼의 핵심 기능을 지원하는 최소한의 테이블 구조를 제시합니다. 

### 주요 설계 성과
- **단순함**: 6개 핵심 테이블로 복잡도 최소화
- **확장성**: Multi-tenant 구조로 수평 확장 지원  
- **유연성**: JSONB 활용으로 스키마 진화 가능
- **성능**: 적절한 인덱스와 정규화 수준
- **보안**: RLS와 암호화를 통한 데이터 보호

이 설계를 기반으로 빠른 MVP 개발이 가능하며, 비즈니스 성장에 따라 점진적으로 확장할 수 있는 견고한 기반을 제공합니다.